{
  "Tutorial_1": "Hey, everybody. How's [it] going in this series of videos? We'll be learning how to create and use classes within python and how object-oriented concepts are applied within the language now There's a lot to cover when working with classes, so I'm going to break these up into several different videos We'll cover the basics of creating and instantiating classes will learn about inheritance class and instance variables static methods and class methods and Several other topics So breaking these up in several videos will allow us to focus on specific topics in each video so in this video We'll be learning the basics of creating and instantiating simple classes, but first Why should we even use classes now this isn't just specific to Python you can see classes being used throughout most modern programming languages, and there's a good reason for that they allow us to Logically group our data and functions in a way that's easy to [reuse] and also easy to build upon if need be Now just a quick side note when I say data and functions that are associated with a specific class We call those attributes and methods, and you'll hear me use those terms a lot throughout these videos, so when I say methods I mean a function that is associated with a class [so] let's go ahead and get started so say we had an application for our company And we wanted to [represent] our employees and our python code now This would be a great use case for a class because each individual employee is going to have specific Attributes and methods so for example each employee is going to have a name and email address [a] pay and also Actions that they can perform so it'd be nice if we had a class That we could use as a blueprint to create each employee so that we didn't have to do this manually each time from scratch So let's go ahead and create a simple employee class and see what that would look like so to create a class It's just as easy as saying class employee now I'm going to leave this empty for now, and if we just left it like this and we get an error so if you ever have a class or a function [that] you want to leave empty for the time being then you can simply put In a past statement and python will know that you just want to skip that for now So now we have a simple employee class with no attributes or methods And I wanted to stop here because I wanted to explain the difference between a class and an instance of a class So our class is basically a blueprint for creating Instances and each unique employee that we create using our employee class will be an instance of that class so for example if I said employee 1 equals employee and EmPLoyee 2 Equals employee then each of these are [going] to be their own unique instances of the employee class so for example if I go ahead and print both of these out and Copy and paste that There and you can see that both of these are employee objects, and they're both unique They both have different locations here in memory now This is an important distinction because you'll hear me talk a lot about instance variables and class variables and it's important to know the difference between those and I'll go more in depth into class variables in the next video but for this video We're going to be looking at instance variables so instance variables contain Data that is unique to each instance Now we could manually create instance variables for each employee by doing something like this So let's say we wanted employee 1 to have a first name and a last name so I could just do employee 1 not first Equals Corey and then I could do employee last is equal to Schaefer and I could also give it an email address, so I'll do employee 1 dot email equals and I'll just do the first name with the last name at Company comm and lastly let's go ahead and add a pay [onto] there too, so I'll do employee 1 not pay and we'll just do 50,000 there now let's give employee to Some of these same attributes so for this one. I'll just do test User and then I'll do test User and I will make that 60,000 ok so now each of these instances have attributes that are unique to them so if I print it out, let's say I could print out the employee [1] dot mail and Also print out the employee to email On it looks like whenever I gave these the instance variables I forgot to make this employee to here so now let's run that so now you can see that that email Was created for each employee? [let's] say that we wanted to set all of this information for each employee When they're created rather than doing all of this manually like we did here So we wouldn't want to have to Manually set these variables every time you can see it's a lot of code and it's also prone to mistakes Just like I did whenever I forgot to change the [to] employee, [too] So we don't get much benefit of using classes if we did it this way, so to make these Set up automatically when we create the employee we're going to use a special init method So now inside of our employee class I'm going to create this special init method Now you can think of this method as initialize and if you're coming from another language Then you can think of this as the constructor now when we create methods within a class they [receive] the instance as the first argument Automatically and by convention. We should call the instance self now. You can call it Whatever you want But it's a good idea to stick to convention here and just use self So after self we can specify what other arguments that we want to Accept so let's go ahead and accept the first name the [last] name and the pay and I know that we had email, too But we can create the email using the first name and the last name so now within our and Knit method We're going to set all of these instance variables So let's do self dot first equals first and now I'm just going to do this for the rest of them as well So [I'm] going to do self dot pay or self dot last and self dot pay and for the email I can do self dot email equals first plus and then we'll put a dot between those and then last and then we'll add on to the end at company comm Okay, so whenever I say that self is the instance what I mean by [that] is that when we self dot first? equals [two] first here It's going to be the same thing as us saying down here that employee one dot first equals [Korey] except now instead of doing this manually It'll be done automatically when we create our employee objects Now these don't need to be the same as our arguments so for example. I could make this Self dot f name equals first, but I usually like to keep these similar if possible So I'm going to go ahead and set that back [to] self dot first equals first, okay? So now when we create our instances of our employee class right here now we can pass in the values that we specified in our anit method now our net method takes the instance which we call itself and the first name last name and Pay as arguments, but when we create our employee down here the instance is passed automatically So we can leave off self we only need to provide the names and the pay so we could create these by Passing in first and we have to do this in order So I will pass in all of the same information that we did manually down there and for the second one I'll do [test] and User and I think I had that at [sixty] [thousand] okay so what would happen on this line when we create this employee the anit method will [be] run automatically, so Employee one will be passed in as self and then it will set all [of] these attributes So it'll set employee one dot first is equal to first which we passed in as quarry Employee one that last equals what we passed in is last and so on so now that we have that an it method in place We can go [ahead] and delete these manual assignments that we made down here And you can see by deleting that that we got rid of a lot of code So I'm going to go ahead and comment out those lines [we're] printing [the] employees, and I'm just going [to] go ahead and print out the email So if I run that then you can see that that still works, okay? So everything that we have so far [like] the names and email and the pay are all attributes of our class now Let's say that we wanted the ability to perform some kind of action not to do that We can add some methods to our class So let's say [that] I wanted the ability to display the full name of an employee now This is an action that you'd likely need to do a lot with a class like this So we can do this manually outside the class if I was to come down here and do Print and I could get the full name just by putting in two placeholders there and doing a format and saying employee one dot first and Employee one dot last and if I go ahead and print this out And you can see that we got the full name there But that's a lot to type in each time that you want to display the employees full name, [so] instead Let's create a method within our class that allows us to put this functionality in one place, so within our class here I'm going to create a method called full name and we can do that with just doing a death of Full name now [like] I said before each method within a class Automatically takes the instance as the first argument and We're going to always call [that] self and the instance is the only argument that we'll need in order to get the full name So within this method here I'm just going [to] take the same logic that we had down here and cut that out and I'm just going to go ahead and return that but we have to be careful here because now instead of printing Employee [1] [first-name] and [lastname], [I'm] going to use self so that it will work [with] all instances So I'm going to do self dot first and self dot last So now that we created that method instead of printing like we did before now I can just come down [here] and do employee 1 dot full name and Print that out And if I run that then you can see that we got the same [thing] and notice that we need the parentheses here Because this is a method instead of an attribute So if I left the parentheses off and printed this then you can see that it prints the method instead [of] the return value of the method so we're going to have to put those parentheses on in order to run that properly so now we have full advantage of Code reviews here, so instead of typing this out for each full name that I want to print now I can just use that method so now if I wanted to print employee two's full name It's just as easy as replacing employee one with employee two and running that and we get the correct answer Okay, and one more quick thing that I wanted [to] point out here Now one common mistake that I see when creating methods is forgetting the self argument for the instance So let's take a quick look at what that would look like if we left that off so now before I run this if I just comment it out this printing of full name down here and Ran this then you can see I'm actually going to remove these print statements here as well Now [you] can see that this runs without any errors But if I was to try to run this method that we accidentally left self off of then Run this and you can see that we get an error and the error that we got was a type error full-name takes zero positional arguments But one was given now this can be confusing because it doesn't look like we're passing any arguments here into full name But the instance which in this case is employee two is getting passed automatically So we have to expect that instance argument in our method, and that's why we added self so I'm going to come back up [here] to full name and Put self back in and now running this you can see that [it] runs Correctly now we can also run these methods using the class name Itself which makes it a bit more obvious of what's going on in the background because whenever we do that, so I'll do employee Dot full name now [when] we run it from the class we have to manually pass in the instance as an argument So in this case I'll pass in employee one so you can see how these are similar, but not exactly the same So I'm going to put these side-by-side just so that we can compare them here So these two lines here do the exact [same] thing, but here when I do employee one Which is a instance and I call the method. I don't need to pass in self It does it automatically and when we call the method on the class And it doesn't know what? instance that we want to run that method with so we do have to pass in the instance and that gets passed in as self and if I go [ahead] and Print this out and run it then you can see that it works Just like if we were to print out the employee one dot full name And I wanted to show you that because that's actually what's going on in the background when we run employee one dot full name it gets transformed into this here employee dot full name and Passes in employee one as self and that's why we have self for these methods, so I hope that makes sense to you That's not extremely important to know when we're just getting started with working with classes But we need to understand that [in] later videos once we start inheriting from other classes and things like that So I figured it would be a good thing to go ahead, and show you that now okay? So I think that's going to do it for this video in this video We learned how to create simple classes the difference between a class and an instance of that class and we also learned how to initialize class attributes and create methods now We still have a lot to cover in future videos, and we'll be going over more advanced topics, so in the next video We'll learn about class variables, and how they differ from instance variables that we saw here But if you do have any [questions] with what we covered in this video Then feel free to ask in the comment section [below] and I'll do my best to answer those If you enjoy these tutorials and would like to support them then there are several ways you can do that The easiest way is to simply like the video and give it a thumbs up and also it's a huge help to share these videos with Anyone who you [think] would find them useful and if you have the means you can contribute through patreon And there's a link to that page in [its] scription section below be sure to subscribe for future videos and thank you all for [watching]",
  "Tutorial_2": "hey there how's it going everybody in the last video we learned how to create a simple class and how to create instances of that class we learned a lot about instance variables which are used for data that is unique to each instance so instance variables are these here that are set using the self argument that we saw before so for example in the employee class that we created we set the names the email and the pay in our Annette method and those are set for each instance of the employee that we create and I briefly mentioned class variables in the last video but we didn't go into detail and that's what we're going to learn about in this video so class variables are variables that are shared among all instances of a class so while instance variables can be unique for each instance like our names and email and pay class variables should be the same for each instance so if you look here at our employee class what kind of data would we want to be shared among all employees well there's a lot of different ideas that we could probably come up with but for this example let's say that our company gives annual raises every year now the amount can change from year to year but whatever that amount is it's going to be the same for all employees so that would be a good candidate for a class variable now before we actually create that class variable let's first hard code this in and see why the class variables would be a better use case so I'm going to create a method down here called apply raise and remember our methods automatically take in the instance which we are going to call self now within this apply raise I'm going to do a self dot pay and I'm going to set this equal to an integer so that we have a whole number and I'm gonna do self dot pay times 1 point let's just make this 4% so now if I was to test this down here on an instance then I can print out the employee 1 dot pay and let me go ahead and copy this twice and between here I'm going to do an employee 1 dot apply raise now if I go ahead and run this Oh actually forgot to put in the parenthesis there so now if I go ahead and run this you can see that I printed out the pay then we applied the raise and it added 4% onto our pay so we can see that it worked but there are a couple of things wrong here so first it would be nice if we could access the raise amount by doing something like employee 1 dot raise amount or since it would apply to the entire class we should also be able to get the raise amount by doing employee dot raise amount now that raise amount attribute doesn't currently exist so we can't see that it is 4% and also what if I wanted to easily update that 4% amount so right now it's kind of hidden within this method and for all I know it could be in multiple places throughout our code so we don't want to have to manually go in if we wanted to update this 4% we wouldn't want to have to manually go in and change these and multiple locations so let's instead pull this 4% out into a class variable and that's as easy as going up here to the top of the class and just saying that we want a raise amount equal to one point and we'll just do that at 4% still so now instead of hard-coding this 4% down here and our apply raise method now let's go ahead and use this class variable now you might expect us to just be able to type in raise amount here but if I save that and I'm going to comment out these lines here so if I save that and run it you can see that I got a name error and it says that raise amount is not defined and that's because when we access these class variables we need to either access them through the class itself or an instance of the class so within the apply raise I could either say employee not raise amount and if I save that and run it then you can see that that works or I can also access through the instance so I can do self dot raise amount and if I run that then you can see that that works as well now that might be a little confusing to you because if these are class variables and why can we access them from our instance so let me print out a few lines here to get a better idea of what's going on so I'm going to go ahead and remove all of these lines here actually I'm going to keep this and I'm going to print out the employee one dot rays amount and I'm also going to print the employee that rays amount and also just to see all of our instances here I'm going to also do the employee two trays amount so that we can see all of them together so now if I go ahead and print these out you can see that I can access this class variable from both my class itself as well as from both instances now what's going on here is that when we try to access an attribute on an instance it will first check if the instance contains that attribute and if it doesn't then it will see if the class or any class that it inherits from contains that attribute so when we access rays amount from our instances here they don't actually have that attribute themselves they're accessing the class's raiseamount attribute now there's a little trick that we can do here to get a better idea of what's going on so I'm going to go ahead and print out the namespace of employee one and we can do that by printing out employee one double underscore vicked it's now if I run this if I were to access these names or email or pay then these are the values that they would return but you can see that there's no raise amount here in this list now if I print it out the employee dict and run that now we're gonna get a few things here that we don't necessarily care about but if we look down here and we can see that the class does contain this raise amount attribute and that is the value that our instances see when we access that raise amount attribute from our instances now let me show you an important concept here so I'm going to go ahead and comment this out and I'm going to take this employee raise them out and I'm going to set this equal to one point zero five and now I'm going to uncomment out our print statements here and rerun this code and you can see that it changed the Rays amount for the class and all of the instances now what if I was to set the Rays amount using an instance instead of using the class so instead of doing employee dot rays amount equals five percent I'm going to say employee one dot rays amount equals five percent so if I run this now now this might be a little unexpected you can see that it only changed the Rays amount for employee one it's the only one that has this five percent so why did it do that well when we made this assignment it actually created the Rays amount attribute within employee one so if I go back up here and print back out employee ones namespace and I'm going to do this under the assignment so now if I run that now you can see that employee one has raised amount within its name space equal to five percent and it finds this within its own namespace and returns that value before going and searching the class and we didn't set that raise amount on employee two so that still falls back to the classes value now that's an important concept to understand because up here and our apply rays method we can see that we could get different results depending on whether we did the self which is the instance raised amount or the employee class raise amount so in this case I think I'm going to go ahead and leave this as self dot raise amount because that will give us the ability to change that amount for a single instance if we really wanted to so if I wanted to change employee ones raise amount then I could go ahead and do that and when I did apply raise then it would use the employee ones raise amount instead of the classes raise amount and also using self here will allow any subclass to override that constant if they wanted to and we'll look at sub classing and future video so now let's look at another example of a class variable where it wouldn't really make sense to use self so let's say that we wanted to keep track of how many employees that we have so the number of employees should be the same for all instances of our class so if I created a class variable up here I'm just gonna go ahead and call this num of employees is equal to zero for now and each time we create a new employee I'm going to increment that by one and I can do that within the knit method since the knit method runs every time we create a new employee so within here I'm going to do employee dot number of employees plus equals one now I'm definitely gonna use employee that number of employees here instead of self dot number of employees because with the raises it's nice to have that constant class value that can be overridden per instance if we really need it to be but in this case there's no use case I can think of where we would want our total number of employees to be different for any one instance so for now I'm going to go down here to the bottom and go ahead and delete all of this and I'm going to print out employee dot number of employees so now if I go ahead and run that you can see that it returned two because it was incremented twice when we instantiated both of our employees here if I was to put this print statement above where we instantiated those employees then you can see that it was zero and we created two employees and then it printed out - okay so I think that is going to do it for this video now I know that that was a lot to take in but hopefully now you better understand the difference between instance variables and class variables and when you would use each one so one of the obvious next questions is well if we have class variables then are there also class methods and the answer is yes there are these things called static methods and also class methods and we'll look at the difference between those in the next video but if you do have any questions about what we covered here then feel free to ask and section below and I'll do my best to answer those if you enjoy these tutorials and would like to support them then there are several ways you can do that the easiest way is to simply like the video and give it a thumbs up and also it's a huge help to share these videos with anyone who you think would find them useful and if you have the means you can contribute through patreon and there's a link to that page in the description section below be sure to subscribe for future videos and thank you all for watching",
  "Tutorial_3": "hey everybody how's it going in our last video we looked at the difference between instance variables and class variables and in this video we'll be learning about the difference between regular methods class methods and static methods and a lot of people get confused as to the difference between class methods and static methods so we'll definitely go over that in detail so as we learned in our previous videos regular methods in a class automatically take the instance as the first argument and by convention we were calling this self so if a regular method automatically takes in the instance as the first argument then how can we change this so that it instead automatically takes the class as the first argument now to do that we're going to use class methods and to turn a regular method into a class method it's as easy as adding a decorator to the top called class method so let's go ahead and create one of these so I'm going to create a new method here with that class method decorator and I'm just going to call this set raised amount now for this set raised amount method I'm going to take in the class and I'm going to take in an amount and for now we'll just put in a pass statement there now if you'd like to learn more about how decorators work then you can watch my video that goes into that in depth but basically this is altering the functionality of our method to where now we receive the class as our first argument instead of the instance now by convention with a regular method we called this instance variable self and there's a common convention for class variables too and that is CLS now we can't use the word class as the variable name here because the word has a different meaning within the language you can see here at up at the top that we use the word class to create a new class so that is a keyword in Python so instead we're going to use CLS as our class variable name so now within this set raise amount method we are working with the class instead of the instance and to show you what I mean by this let's go ahead and set our class variable raise amount so we'll say class dot raise amount and we'll just set this equal to the amount argument that we are accepting from this method so now down here at the bottom I still have these two employee instances that I created in our previous tutorials and Here I am printing out the classes raised amount as well as both instances raised amounts so if I go ahead and run this then you can see that all of those are equal to 4% now the reason all those are equal to 4 percent again is because we have this class variable here raised amount that is set to 4% so now let's say that we wanted to change this to 5% so before I print these out then I could just use that raised set raise amount method that we just created and I could do employee dot set raise amount and it automatically accepts the class so we don't have to pass that in so now we can just pass in an amount so I'm going to go ahead and do 5% and if I save that and run it and you can see that now all of these are equal to 5% now the reason all those are equal to 5% is because we ran this set raise amount method which is a class method which means that now we are working with the class instead of the instance and we're setting that class variable raise amount equal to the amount that we passed in here which is 5% so really us running this set raise amount method here and setting this CLS variable raise amount to the amount is the same thing as us saying employee dot raise amount equals 5% but now we are using this class method to do that instead now you can run class methods from instances as well but that doesn't really make a lot of sense and I don't ever see people doing it but to show you what that would look like I can also grab this instance here and I can run that class method from the instance and if I run that you can see that running that class method from the instance still changes that class variable and sets all of the class variable and both instance amounts to that 5 percent that we passed in now you may also hear people say that they use class methods as alternative constructors now what do they mean by this so what they mean is that you can use these class methods in order to provide multiple ways of creating our objects so let's say that for example we had someone who is using our employee class and they said hey I have these specific use cases where I'm getting employee information in the form of a string that is separated by hyphens and I'm constantly needing to parse the string before I create new employees so is there a way to just pass in a string and create an employee from that so let's go ahead I have an example down here to where we can see exactly what this problem would look like so let's say that this is a common use case for how someone is using our class we have three strings here that are employees separated by hyphens so we have the first name the last name and the salary and they're all in a string and they're separated by hyphens now if I wanted to create a new employee from this string then what I would have to first do is I would have to split this string on the - and then we'd have our first name last name and our pay and then based on those values we would be able to create a new employee by passing in those values and that would run our a knit method so now let me go ahead and save this and run it and you can see that this works we're splitting the string up into a first name last name and pay and then we are creating a new employee just like we did up here out of those values that we parse from the string and you can see that it works because we're printing out that new employees email and pay and everything is as it should be but if this is a common use case for how someone is using our class and we don't want them to have to parse these strings every time that they want to create a new employee so let's just create an alternative constructor that allows them to pass in the string and we can create the employee for them so I'm going to go ahead and come up here and create a new class method and we're going to use this new method as an alternative constructor and usually these start with the from but that's just a convention also but I'm going to call this from string and remember that we automatically accept the class as the first argument there and I'm just going to call this second argument employee string and now we're just going to go ahead and parse this string for them so exactly what we did down here I'm just going to grab this line first name last name and pay and I'm going to go ahead and put this in our class method but now instead of working with this specific string I'm going to split the string that they pass to this method so instead of employee string one I'm going to use this employee string argument from this method here and down here at the bottom we created our new employee by saying employee and then passing in those variables that we got when we split but now that we're inside of our class method we can do the exact same thing but now we're going to use our class variable instead of employee because those are the same thing so I'm going to go ahead and grab this line here and paste it in but now I'm going to use this class instead of employee since that's basically the same thing so this line is going to create that new employee and now that we've created that new employee we also need to return it so that they can receive that employee object when this method is called so I'm just going to return that new employee object okay so now our alternative constructor is done so now I can delete this line here and now instead of someone needing to parse the string themselves we've provided them with this from string method that they can call and you see here that they are just passing in this employee string one and it comes in here and it splits that string on the - and then creates a new employee object and then returns that employee object so now if I save this and run it you can see that we got the exact same values so now they'd have no need to parse the strings anymore we've provided them with a from string alternative constructor and now they can just pass in those strings and get their new employee objects so when people say that they use class methods as alternative constructors then this is what they mean now if you want to see a real-world example of this then I have the date/time module pulled up here and there are several ways that we can create new date times and if you search for class method within the date/time module then you can see an example of some of these so the default way of creating a date/time object is to say something like date/time and then pass in the year month and date but if we look here at these class methods which are alternative constructors then what they do is they have this from time stamp and you can use the current time which is today and they have a couple of other examples here as well and you can see that they're basically doing the same thing that we just did in our example so you can see that they are accepting the class and a timestamp with this from time stamp constructor and then they are parsing out some dates and then they're creating that new date/time object and returning that so it's a new way of creating date/time objects so that is very similar to the example that we just wrote on our own so now if you ever see something like this in code then you'll know what's going on okay so now that we looked at class methods now let's talk about static methods now a lot of people gets class methods and static methods confused now when working with classes regular methods automatically pass the instance as the first argument and we call that self and class methods automatically pass the class as the first argument and we call that CLS and static methods don't pass anything automatically they don't pass the instance or the class so really they behave just like regular functions except we include them in our classes because they have some logical connection with the class so let's go ahead and take a look at an example so that we know what we mean here so I'm going to go ahead and delete these lines here so let's say that we wanted a simple function that would take in a date and return whether or not that was a workday so that has a logical connection to our employee class but it doesn't actually depend on any specific instance or class variable so instead I'm going to make this a static method so to create a static method it's just as easy as a class method and we're also going to use a decorator that decorator is going to be static method so I'm going to call this method is workday now remember static methods don't take the instance or the class as the first argument so we can just pass in the arguments that we want to work with and I'm going to take in a day here and return whether or not that is a workday so to make this a simple example I'm not going to do it to anything too complicated I'm just going to return whether or not our day falls on a weekday so in Python dates have these weekday methods where Monday is equal to zero and Sunday is equal to six and all the other days in between so if I wanted to return whether this is a weekday and I could just say they dot weekday if that is equal to five well which is a Saturday and I'm going to go ahead and just copy this line here and say or if that day is equal to six which is a Sunday then I'm going to return false and if it doesn't hit that conditional then it means that it's a weekday so I'm just going to return true now sometimes people write regular methods or class methods that actually should be static methods and usually a giveaway that a method should be a static method is if you don't access the instance or the class anywhere within the function so say that I had this class method up here you can see that I'm using that class variable there but if I wasn't using it anywhere within that method then it probably doesn't need to be a class method and the same with regular methods if you're not using that self variable then it's probably you probably want to check and see if that would be appropriate to use a static method that place okay so now let's go down here and see if our static method is working so I'm just going to go ahead and uncomment out these couple of lines here and all I'm doing here is I'm importing the eighth time module and then I'm creating a new date and if I wanted to use our new static method here that checks whether this date is a weekday then I can just print out the employee dot is work day and pass in that date so if I run that on I got an error there because whenever I copied and pasted I forgot to take out this second if I really want that to say if the weekday is equal to five or the weekday is equal to six so now if I save that and run it then you can see that this day that I passed in is false because that's actually a Sunday now if I replace this with the 11th and run that now you can see that it's a Monday so you can see that his workday returns true okay so I think that is going to do it for this video in this video we learned the difference between regular instance methods class methods which can also be used as alternative constructors and static methods which don't operate on the instance or the class so I hope all of that made sense to everyone but if you do have any questions about anything that we cover then feel free to ask in the comment section below and I'll do my best to answer those in the next tutorial we'll start looking at inheritance and how we can make subclasses now if you enjoy these tutorials and would like to support them then there are several ways you can do that the easiest way is to simply like the video and give it a thumbs up and also it's a huge help to share these videos with anyone who you think would find them useful and if you have the means then you can contribute through patreon and there's a link to that page in the description section below be sure to subscribe for future videos and thank you all for watching",
  "Tutorial_4": "hey everybody how's it going in this video we'll be learning about Python class inheritance now just like it sounds inheritance allows us to inherit attributes and methods from a parent class now this is useful because we can create subclasses and get all the functionality of our parent class and then we can overwrite or add completely new functionality without affecting the parent class in any way so let's go ahead and look at an example of this and we'll see why this is useful so for our object-oriented video so far we've been working with this employee class now let's say that we wanted to get a little more specific here and create different types of employees so for example let's say that we wanted to create developers and managers now these will be good candidates for subclasses because both developers and managers are going to have names email addresses and a salary and those are all things that our employee class already has so instead of copying all this code into our developer and manager subclasses we can just reuse that code by inheriting from employee so let's go ahead and create these developer and manager subclasses and it's just as easy as creating a new class just like we did up here with employee but we're going to call this new class developer and after the name of class we can put these parentheses here and specify what classes that we want to inherit from so in this place we want to inherit from the employee class now I'm just going to put in this past statement here for now because I want to show you that by simply inheriting from that employee class that we inherited all of its functionality so right now even without any code of its own the developer class will have all of the attributes and methods of our employee class so right now down here I have two instances of our employee class and then I'm printing out both of their emails so if I save this and run it you can see that when we create two new employees and print out their emails that we get this result so now instead of creating two new employees I'm now going to create two new developers and pass in all of the same information so now if I rerun this and print out those emails you can see that those two developers were created successfully and we can access the attributes that were actually set in our parent employee class so what happened here is that when we instantiated our developers it first looked in our developer class for our annette method and it's not going to find it within our developer class because it's currently empty so what python is going to do then is walk up this chain of inheritance until it finds what it's looking for now this chain is called the method resolution order now I want to show you there's really useful function here that makes these things a lot easier to visualize and that is the help function so first I'm going to copy out these two lines here and then I'm just going to print out this help function and I'm going to pass in the developer class so if I go ahead and run that and I'm going to make this a little bit bigger here now you can see that when we run help on that developer class that we get all kinds of good information here so that method resolution order that I mentioned is one of the first things that gets printed out and basically these are the places that Python searches for attributes and methods so when we created our two new developers here it first looked at our developer class for the init method and when it didn't find it there then it went up to the employee class and it found it there so that's where it was executed now if it hadn't found it in our employee class then the last place that it would have looked is this object class and every class and Python inherits from this base object now if we look at this output further then it actually shows the methods that were inherited from employee so you can see here that we have the net method and we also have our apply raised method and our full-name method and if I keep scrolling down here then you can also see that we have our data and other attributes and you can see that the class attribute raised amount was also inherited from the employee class so we got all of this code for free just by inheriting from that employee class okay so now I'm going to go ahead and make this smaller again and I'm going to take out that printed help statement okay so now let's say that we wanted to customize our subclass a little bit now I'm going to make a simple one-line change in here and I'm just going to change the raise amount but first let's go ahead and see what happens when we apply arrays on our current developer so I'm going to print out this should actually be pay and this should be pay now I'm going to print out our current developers pay here which should be 50,000 then I'm going to apply a raise and it should find our employees raise amount of 4% and that I'm going to reprint out that developers pay again so if I save that and run it you can see that it printed out 50,000 applied the raise and then printed out 4% higher but let's say that we wanted our developers to have a raise amount of 10% now to change that it's just as easy as coming into our developer class here and it's changing the raise amount to 10% so now if I go ahead and rerun this you can see that it used our developer class's raise them out instead of our employee classes raise them out now if I was to change this instance back to an employee instead of a developer and then reran this then you can see that now it's back to that employee 4% amount so the thing to take away here is that by changing the raise amount and our subclass it didn't have any effect on any of our employee instances so they still have that raise amount of 4% so we can make these changes to our subclasses without worrying about breaking anything in the parent class okay so now I'm going to go ahead and change this back to a developer and we'll make a few more more complicated changes so sometimes we want to initiate our subclasses with more information than our parent class can handle so what do I mean by that so let's say that when we created our developers here that we wanted to also pass in their main programming language as an attribute but currently our employee class only accepts first-name lastname and pay so if we also wanted to pass in a programming language there then to get around this we're going to have to give the developer class its own and net method so what I'm going to do is I'm just going to go up here to our employee class and grab that init method and I'm going to paste it here within the developer class now along with the first name last name and pay I'm also going to add in an argument here for the programming language now what you might be tempted to do here is just go up and copy all of this code from our employees classes and knit method and paste it into our developer classes init method but we don't want to do that because we want to keep our code dry and not repeat this logic in multiple places because we want it to be as maintainable as possible so instead of copying and pasted pasting that what we're instead going to do is just let our employees and knit method handle the first name last name and pay and then we'll let the developer set the programming language so in order to let that employee handle the first name last name and pay what we can do here is just do super dot and knit and then we can pass in the first last and pay so again super dot knit is going to pass first last and pay to our employees and knit method and let that class handle those arguments now there's multiple ways of doing this logic here you may have seen some people do employee dot a knit and instead of passing in first last and pay they'll type in self and then first last and pay now both of these ways of calling the parents and knit method will work but I tend to use super because with single inheritance like we are using here it's a little bit more maintainable but it's really necessary once you start using multiple inheritance and we're going to go over that in a future video but to keep things simple I usually just like to always stick with super so now that we're letting our employee classes a tenth method handle the first last and pay now we can handle the programming language argument just like we would in the other class so I can just say self dot programming language equals the programming language that we passed in here okay and that should be all we need for our anit method so now when we instantiate our developers down here it's also going to be expecting a programming language to be passed in so I'm just going to go ahead and pass in Python for our first developer and I'll pass in Java for our second developer so now to make sure that this worked I'm going to comment out those lines there and I'm going to print out the first developers email I'm also going to print out the first developers programming language okay so if I run that then you can see that both of those were set correctly so we got the email set I it when we passed in all of our arguments here it came up here and it ran our employees and knit method and set all of those within there and then it also set our programming language within our developers init method there so you can see why this sub classing is useful because we were able to customize just a little bit of code and we got all of this code from our employee class for free just by adding in that one little line there okay so just so we can get a really good understanding of this let's go through the process of creating another subclass called manager and I'll go through all these steps again but I'll go a little bit faster this time okay so right here below our developer I'm going to create a another class and I'm going to call this class manager and if this is also going to inherit from employee now when I create a new manager I'm going to give the option of passing in a list of employees that this manager supervises so we're going to need to add an a knit method for our manager and instead of typing all this in I'm just going to grab this Anette method here from our developer and paste this in here okay but this is going to be a little bit different instead of a programming language for our manager I'm going to let them pass in a list of employees and I'm going to set the default to none and then instead of setting this programming language here I'm say if employees is none self dot employees is equal to an empty list and then else self dot employees equals employees now you might be wondering why I didn't just pass in an empty list as default argument here instead of none but you never want to pass mutable data types like a list or a dictionary as default arguments and that's a topic for another video and I plan on doing one on that soon but for now we'll just go ahead and set our employees to an empty list if the argument is not provided and set them equal to that employees list if it is okay so now let's add in a few methods here so I'm going to give the option to add and remove from our list of employees that our manager supervises and to do this I'll add in a method called add employee and add employee will take self just like all of our instance methods do and employee and then I'll just say if the employee is not in self dot employees then I will just append that employee to our lists so self dot employees dot append that employee and now I'm also going to create another method here to remove employees from this list and it's going to be similar so I'm just going to go ahead and copy that but this is going to be removed and we'll say if the employee is in our list of employees then remove that employee ok and lastly I'm going to add a method that will print out all of the employees that this manager supervises so I'm going to call this method print employees and this isn't going to take any more arguments than just self and I'll say for employee in self dot employees and then I will just print out that employee and before the employee I'll go ahead and put an arrow here just so it sticks out a little bit further and instead of just printing the employee I'll actually print the employee full-name okay so I think that we are finished with our manager class so we have our own init method here which it'll accept a first name last name and pay and also a list of employees that this manager supervises and then we have the ability to add employees to that list remove employees from that list and to print out all the employees from that list so now let's see if this works so I'm just going to comment out these lines here and now I'm going to create a new manager and I'll call this manager one so now I want this to be a manager and for the first name I'll do su for the last name I'll do Smith will say that the pay is ninety thousand and let's say that she supervises this first developer here so now let's make sure that this manager was successfully created and that we have all of the attributes and methods available that it would have inherited from that employee class so let's go ahead and print out this managers email address so now if I go ahead and print this out you can see that the email address was set correctly but now we also added down all of this extra functionality so let's see if we can print out all the employees that this manager supervises so I'll do manager dot print employees and if I go ahead and run that then you can see that it prints out the full name of the one employee that they currently supervise and I can add to that list of employees so here I'll just say manager one dot employee and I'll pass in this second developer here before we print out that list of employees now if I print that out you can see that now they are supervising two employees and we also have the ability to remove employees so I will remove our first employee here from their list of people who they supervise so now if I save that and run it you can see that that first developer was removed from that list and they only have the second developer in that list so just like with our devel upper-class you can see how useful this actually is because all of the code in here is specific to what we want for a manager and in our developer class it's specific to what we want for a developer and we're inheriting all of this common code from employee so we really get to reuse our code nicely here if we use subclass incorrectly okay so now I'm just going to go ahead and remove all of this code here now I know that this video is getting a little long but I want to show you a couple more quick things here so python has these two built-in functions called is instance and is subclass so is instance will tell us if an object is an instance of a class so for example if I need to print this out I can print out whether manager one is an instance of manager and if I print that out you can see that it prints true now if I was to check whether the manager is an instance of an employee then you can see that that is also true but if I check if manager one is an instance of a developer then that returns false because even though developer and manager both inherit from employee they aren't part of each other's inheritance so along those same lines we have this is subclass function and is subclass will tell us if a class is a subclass of another so for example I could do is developer a subclass of employee and if I run that you can see that it returns true and if I do is manager a subclass of employee if I run that you can see that that returns true also but if I say is manager a subclass of developer then that will return false so those built in is instance and is subclass functions may come and use when you're experimenting with inheritance on your own ok so very last thing I always like to show you all practical real-world examples of this stuff whenever I can and one of the easier examples I found up sub-classing was within the exceptions module of this Python whisky library so this is a really popular library and used in a lot of different projects so if we look here we can see that this HTTP exception class inherits from this base exception and they say here that this HTTP HTTP exception is the base class for all HTTP exceptions now if we scroll down here you can see this is that this has a lot of code in this class but once we get far enough along we can see that we have some other classes here that inherit from that base HTTP exception class so here we have this bad request that inherits from HTTP exception and since it inherits from that base class it gets all of that code that we just solve for free and now it can just simply modify this return code and a description without needing to rewrite all of that code from the parent class so you can see how using inheritance like this would be extremely useful as your projects grow in size and makes everything much easier to maintain okay so I think that is going to do it for this video in the next video we will go over special and magic methods and how to use those within classes but if you do have any questions about what we covered in this video then feel free to ask in the comment section below and I'll do my best to answer those now if you enjoy these tutorials and would like to support them then there are several ways you can do that the easiest way is to simply like the video and give it a thumbs up and also it's a huge help to share these videos with anyone who you think would find them useful and if you have the means you can contribute through patreon and there's a link to that page in a description section below be sure to subscribe for future videos and thank you all for watching",
  "Tutorial_5": "hey everybody how's it going in this video we'll be learning about special methods that we can use within our classes and some people call these magic methods now these special methods allow us to emulate some built-in behavior within Python and it's also how we implement operator overloading so what I mean by that is for example when we add two integers together so down here I'm going to print out one plus two and when we add two strings together so I'm going to print out a plus B if I run this code then you can see that the behavior when we add two strings together is different than when we add two integers together so the strings were just concatenated and the integers were actually added together so depending on what objects you're working with the addition actually has different behavior and also if we were to print out our employee instance here then you can see that we just get this vague employee object and it would be nice if we could change this behavior to print out something a little bit more user-friendly and that's what these special methods are going to allow us to do so by defining our own special methods we'll be able to change some of this built-in behavior and operations so these special methods are always surrounded by double underscores so a lot of people call these double underscores dunder so if you ever hear someone say something like dunder an it then they mean an it surrounded by double underscores so speaking of dunder init that is a special method that we've already been using and are familiar with and it's probably the first and most common special method that people use when working with classes so just like we learned in previous videos this special dunder init method is implicitly called when we create our employee objects here and it comes in and sets all of our attributes for us so let's take a look at some other common special methods so two more common special methods that we should probably always implement are this dunder our EPR and under STR now these are what are implicitly called anytime we run our EPR on one of our objects or STR on one of our objects and these are what we're going to use to fix our problem of printing out this vague employee object when we printed out our employee instance here now I have an earlier video on the difference between these two methods but in short our EPR is met to be an unambiguous representation of the object and should be used for debugging and logging and things like that it's really meant to be seen by other developers and STR is meant to be more of a readable representation of an object and is meant to be used as a display to the end-user so let's go ahead and write code for these and take a look at the difference so first we want to be sure to at least have an AR EPR method because if we have this without an STR then calling STR on an employee we'll just use the re PR as a fallback so it's good to have this as a minimum now a good rule of thumb when creating this method is to try to display something that you can copy and paste back in the Python code that would recreate that same object so for example here if I was to come in here and return so we would want this to be something that we could use to recreate this object so I'm going to say employee and then in quotes I'm just going to put a placeholder there and I'm going to do quotes again for the last name and then I'll do another placeholder for the pay and then I'll just go ahead and create a format string here and let's do self dot first self dot last and self dot pay so again what I was doing here is that I was trying to return a string that I can use to recreate the object so to show you what I mean let's go ahead and print out this employee one again so first I'm just going to go ahead and comment out these lines here now remember when I printed out this instance before then we got this vague employee output here but now whenever I rerun this with this re PR method now you can see that it returned the string that we specified in our APR method and you can see how if I wanted to recreate this employee object then I can just copy this output and it's the exact same thing that we used to create that employee to begin with so now let's go ahead and fill in the code for our dunder string method so this is meant to be more readable for an end user so this is a little bit more arbitrary but to print out this employee let's see I'll just say something like I'll do a return and I'll do a placeholder for their full name and a placeholder for their email and then I'll just go ahead and pass those in so I'll do self dot full name and then I'll also do self dot email so now if I print out this employee object again now it should use that dunder STR method instead so now when we print out that employee object its printing out the employee's full name and email address now we can still access the re PR and the STR specifically if I was to go in here and print both of these out and then let me go ahead and close those off and I'll comment out that now really when we run this re PR and STR what's actually going on in the background is that it's directly calling those special methods so let me go ahead and copy these out and instead it's actually calling this double underscore re PR and then if I go ahead and grab this then I'll also print out the STR and if I run that then you can see that we got the exact same object by calling those directly so these two special methods allow us to change how our objects are printed and displayed now to be honest unless you're writing some more complicated classes these three methods of a knit re PR and STR will be the ones that you'll probably use most often but let's go ahead and look at a few more just so we can get an idea of how these work now there are also a lot of special methods for arithmetic so like we saw before when we added those two integers together so if I was to say print 1 plus print 2 now if I go ahead and run this now what this is actually doing is it's using a special method in the background called dunder add so I can actually access this directly if I use the integer object I can do dunder add and I can pass in arguments of 1 & 2 so if I run that and you can see that that gives us the same result and strings are actually using their own dunder add method so if I use a string object and do a dunder ed and pass in a character of a and a character of B and run that then you can see that the strings dunder add actually can cats those together so it can actually customize how addition works for our objects by creating that dunder add method so let's say that with our employee class we wanted to be able to calculate total salaries just by adding employees together now that's kind of a contrived example because if I was to make a class like that in real life then it's probably better to be explicit about what you're adding together but just for the sake of this example let's go ahead and see how we do this and we'll look at some better real-world examples from the standard library here in just a minute so if I wanted to add two employees together and have the result be their combined salaries then we're going to have to create a dunder add method so I'll go ahead and do that and this is going to take in self which is going to be what's on the left side of the addition and other which will be on the right side of the addition and for this example we're just going to assume that these are both employee objects so we want to return self dot pay and added two other dot pay so when we add two employees together it's going to give us their combined pay added together so let's go ahead and see if this works so here I can just print out employee 1 plus employee 2 and if I go ahead and run that you can see that when we added these two employee objects together that it gave us their combined salaries now if we didn't have this dunder add method and I copy and I comment out that then you can see if I try to run that then it gives us an error here and it says that it doesn't know how to add these two employees together so if we put that back in then we are telling it how we want to add these employees together so if I run that then you can see that that works now there are all kinds of these special methods for arithmetic and if I go to the documentation here you see that there are special methods for subtracting multiplying dividing and plenty of others so let's go ahead and run through one more example here before we look at some of these real-world examples in the standard library so if you have ever used the le n function to check the length of a list or a string now this is also a special method so if I wanted to print the length of a string so for example I could say print le n of the string test and let me go ahead and get rid of that print statement there if I run that you can see that that string is four characters long now this is also just using a special dunder method in the background so if instead I was to print test and on that string object I could actually specifically run that dunder length method and if I run that then you can see that we get the same result so if we want this Len function to work on our objects then we'll have to create a dunder Len method so let's say that for example when we ran len on our employee instance that we wanted it to return the total number of characters and their full name and maybe this could be useful if someone's writing a document and needs to know how many characters the employees name will take up so I can create this dunder Len method just by saying def dunder Lynn and this is only going to take in self and now for this I just want to return the length of self dot full name so now we can actually use this Len function on our objects so if I was to pass in employee one here and print that out you can see that we get 13 characters when their full name is printed out now there are a ton of other special methods that we could go over so you can use these to customize how objects are compared how they check for equality and a lot of other useful stuff that we're not going to be able to fit into one video but if you go to the documentation then you can see a short description of all the ones that you can use and I'll put a link to that page in the description section below so now let's go ahead and take a look at some real-world examples in the standard library so can see how useful these can be in real code so I've got the date/time module pulled up here so in the day time module I'm just going to do a search here for dunder add so the first result that we land on here is from the time delta class and you can see that they are checking if the other object that they're adding against is another time Delta and to add those together they are just returning another time Delta with the days seconds and microseconds added up from both of those and if the other object isn't a time Delta and it's going to come down here to this return not implemented now that's something that we didn't go over in our examples but basically when they return not implemented they don't want to throw an error because the other object might know how to handle that operation so returning not implemented is a way to fall back on the other object to see if it knows how to handle the operation and if none of them know how to handle it then it will eventually throw an error okay so let's go ahead and take another look at another example so I'm going to search here for the date class so now we're here within the date class and I'm just going to scroll down here a little bit and here we can see that they have their dunder our EPR method and you can see that they give some examples of what the output should look like and just like we talked about earlier it looks just like how you would create a date object and if we scroll down a little bit further here now here we can see that they're setting their dunder string method equal to the ISO format function so when you print the date it'll actually print out the ISO format so that's pretty interesting so you can see how learning about these things makes it a little less intimidating to look around and the standard library and it makes it a little easier to just be able to look under the hood and see what's going on now don't get me wrong there's a lot of complex code in here but learning how these special methods work is a big step towards better understanding a lot of what's going on in here okay so I think that is going to do it for this video I hope this gave you a better idea of how these special methods work and what's going on in the background when you're performing some of these operations but if you do have any questions about what we covered in the video then just feel free to ask in the comments section below and I'll do my best to answer those if you enjoyed this tutorial I'd like to support them then there are several ways you can do that the easiest way is to simply like the video and give it a thumbs up and also it's a huge help to share these videos with anyone who you think would find them useful and if you have the means you can contribute through patreon and there's a link to that page in the description section below be sure to subscribe for future videos and thank you all for watching",
  "Tutorial_6": "hey there how's it going everybody in this video we're going to be learning how to use the property decorator now this allows us to give our class attributes getter setter and a leader functionality like may have seen in some other languages so if you've been following along with my object-oriented video so far you may have noticed that I stripped down the employee class here a bit and that's just so we can focus on these attributes without the other code getting in the way okay so so far with our employee class some of you may have noticed that our email attribute depends on our first name and our last name so when we create our employee object here it comes into our and NIP method and it sets the first name the last name then it sets the email to our first name dot last name @ email com and also we have this full name method down here which prints out the current first-name and lastname together so if I go down here and create this simple employee object and then print out the first name email and full name you can see that all of these are what we would expect so the first name is John the email is John Smith at email comm and the full name is both of those together so let's go here and now let's set our employee dot first-name I'm just gonna set that first name equal to Jim and rerun this so you can see down here that the first name was changed to Jim but the email still has our old first-name now the full name method here doesn't have this problem because every time we run the full name method it comes in here and grabs the current first-name and lastname so what if the people who are using our class said that we need to fix this so they don't want to change the email every time they change the first name or the last name so they want us to make it to where it updates the email automatically when either the first name or the last name has changed now your first thought there might be to just create an email method just like we did here with our full name but the problem with that is that it will break the code for everyone currently using the class so they would have to go through and change every instance of the email attribute with an email method now this is usually where people from other languages like Java will bring up the benefits of getter and setter methods and it's a good point because this is where getter and setter really come in handy but we have the ability to do this within Python using the property decorator now the property decorator allows us to define a method but we can access it like an attribute so for example let's go ahead and pull this email attribute out into a method similar to our full-name method so I'm actually just going to copy the full name method here and paste this in and I'm going to call this email but instead of printing this out like the first name I'm going to print this out like our email would show up so the first name dot last name @ email comm and so now I'm just going to come up here and remove our email attribute and save that so right now our email method is similar to our full-name method so each time we ran it it would get the current first name and last name but we'd also have to go through and change our code to where every email attribute is a method call so for example when I'm printing this out down here out instead have to go down here and add parentheses to this dot email and so now if I run this here you can see that this solved our problem where it set our email address to the new first name but this also means that anyone using our class would have to change their code also so that's not what we want so let's go ahead and take these parentheses back off so in order to continue accessing email like an attribute I can just add a property decorator above this method so I'm going to go ahead and add this on so this is just at property and just by making that small change now if I run our code then you can see that that works so we're defining our email in our class like it's a method but we're able to access it like an attribute and we could do this just as easily with full name as well so if I was to add this property decorator onto full name and then take off these parentheses there and run that then you can see that that works also now I know that goes against what I said about changing the code but this is just an example and I also wanted to use the full name to show you an example of you can use a setter so let's say for example that we wanted the ability to say employee one dot full name and set it equal to let's just say quarry Schaefer and let's say that by setting this full name that we also wanted it to change our first name our last name and our email and right now we can't do this so if we only have the full name with the property decorator and I try to set this like this if I run this here you can see that we get an error there and if we look at the error it says that we can't set the attribute okay so for now I'm just going to comment this out and rerun that so in order to do what we were trying to do there we're going to have to use a setter and that's going to be another decorator now this might look a little strange but the name that we're going to use for our setter is going to be the name of the property so in this case it's going to be full name so I'm going to say at full name dot setter and then underneath this decorator we just need to create another method with the same name so this is going to be a method with full name this is going to take in self and I'm going to call this name now this name value here is the value that we are trying to set so in this case down here it would be this full name here so I'm going to come in here and we want to set the first name and the last name using this full name here so what we can do is we can just split that name that we pass in on the space separator so I'll say first last is equal to name not split will split on that space so that's going to split that name into two parts and the first part before the space will be the first name and the second part after the space will be the last name so now we want to set our employees first name and last name equal to those values so I can just say self dot first is equal to first and self dot last is equal to last so now that I have that setter if I come down here and uncomment out this line that gave us an error before and rerun that then you can see that that works so what happened here is that whenever we set this full name equal to this name it came into our setter here and it parsed the names from that value that we set and then it set our first name and last name and since we set the first name and last name even when we printed out our email it came in here and grabbed those correct values they can also make a deleter in the same way so let's say that if I was to delete the full name of our employee that I wanted to run some kind of cleanup code so to do this I'm just going to copy our setter here and paste this in below but instead of a setter this is going to be a leader for full name the leader and this won't be accepting any other values other than self and I'll just go ahead and remove these here and just so that we can see this doing something within here I'm just going to say delete name and I'm also just going to do a self dot first is equal to none and a self dot last is equal to none so the deleter code there is what gets run whenever we delete an attribute so at the very bottom here if I do a delete of employee one dot full name and run that then you can see here that it came in and ran that print statement that was in our deleter and also set our first name and last name equal to none values okay so I think that's going to do it for this video I hope you got some ideas for how you can use the property decorator within your classes now this is a nice feature because it allows us to access attributes without putting getters and setters everywhere but if we need that functionality then it's easy to add in with the property decorator and if you do this correctly then people using our class won't even need to change any of their code because they'll still be able to access those attributes in the same way that they did before now that wasn't exactly the case in our example here because I changed the full name method into an attribute but only did that because I wanted to show how we could use the full name as a setter to change the first name and the last name so you won't want to be careful with changes like that if other people are already using your classes so if anyone has any questions about what we cover in this video then feel free to ask in the comment section below and I'll do my best to answer those if you enjoy these tutorials on the bike to sport then there are several ways you can do that now the easiest ways to simply like the video and give it a thumbs up and also it's a huge help to share these videos with anyone who you think would find them useful and if you have the means you can contribute through patreon and there's a link to that page in the description section below be sure to subscribe for future videos and thank you all for watching"
}
